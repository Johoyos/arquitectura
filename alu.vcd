$date
	Sun Jun 14 22:40:42 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module ALU_tb $end
$var wire 32 ! result [31:0] $end
$var reg 32 " a [31:0] $end
$var reg 4 # aluop [3:0] $end
$var reg 32 $ b [31:0] $end
$scope module alu_tb $end
$var wire 32 % A [31:0] $end
$var wire 4 & AluOp [3:0] $end
$var wire 32 ' B [31:0] $end
$var wire 32 ( logic_result [31:0] $end
$var wire 32 ) arith_result [31:0] $end
$var wire 32 * Result [31:0] $end
$scope module Logic $end
$var wire 32 + A [31:0] $end
$var wire 4 , AluOp [3:0] $end
$var wire 32 - B [31:0] $end
$var reg 32 . Result [31:0] $end
$upscope $end
$scope module arith $end
$var wire 32 / A [31:0] $end
$var wire 4 0 AluOp [3:0] $end
$var wire 32 1 B [31:0] $end
$var reg 32 2 Result [31:0] $end
$upscope $end
$scope module mux $end
$var wire 32 3 A [31:0] $end
$var wire 32 4 B [31:0] $end
$var wire 1 5 selector $end
$var wire 32 6 Result [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1110 6
05
b1110 4
bx 3
b1110 2
b11 1
b0 0
b1011 /
bx .
b11 -
b0 ,
b1011 +
b1110 *
b1110 )
bx (
b11 '
b0 &
b1011 %
b11 $
b0 #
b1011 "
b1110 !
$end
#1000
b1000 !
b1000 *
b1000 6
b1000 )
b1000 2
b1000 4
b10 #
b10 &
b10 ,
b10 0
#2000
b1 !
b1 *
b1 6
b1 )
b1 2
b1 4
b1010 #
b1010 &
b1010 ,
b1010 0
#3000
b11 !
b11 *
b11 6
15
b11 (
b11 .
b11 3
b100 #
b100 &
b100 ,
b100 0
#4000
b1011 !
b1011 *
b1011 6
b1011 (
b1011 .
b1011 3
b101 #
b101 &
b101 ,
b101 0
#5000
b1000 !
b1000 *
b1000 6
b1000 (
b1000 .
b1000 3
b110 #
b110 &
b110 ,
b110 0
#6000
b11111111111111111111111111110100 !
b11111111111111111111111111110100 *
b11111111111111111111111111110100 6
b11111111111111111111111111110100 (
b11111111111111111111111111110100 .
b11111111111111111111111111110100 3
b111 #
b111 &
b111 ,
b111 0
#7000
